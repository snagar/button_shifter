# This starter workflow is for a CMake project running on multiple platforms. There is a different starter workflow if you just want a single platform.
# See: https://github.com/actions/starter-workflows/blob/main/ci/cmake-single-platform.yml
name: release - multi platform
on:
  push:
    branches: [ "main" ]
  # Allows you to run this workflow manually from the Actions tab
  workflow_dispatch:

jobs:
  pre-build:
    #if: ( 1 == 2 )
    runs-on: ubuntu-latest
    outputs:
      global-tag-type: ${{ steps.strings.outputs.global-tag-type }}
      global-special-build_text: ${{ steps.strings.outputs.global-special-build_text }}
      global-subversion-text: ${{ steps.strings.outputs.global-subversion-text }}
    steps:
      - uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: Set global reusable strings
        # Turn repeated input strings (such as the build output directory) into step outputs. These step outputs can be used throughout the workflow file.
        id: strings
        shell: bash
        run: |
          TARGET_BRANCH="dry-run"
          VERSION_HPP="#define SPECIAL_BUILD"
          VERSION=${{ github.ref_name }}  # Could also used: ${GITHUB_REF##*/}
          echo "\nCurrent TAG Version: ${VERSION}\n"
          
          if [[ $VERSION == *"-test"* || $VERSION == t* ]] # if TAG contains -test or starts with "t"
          then
            echo "This is a just a test build"
            TARGET_BRANCH="build-test"
          elif [[ $VERSION == *"-beta"* || $VERSION == b* ]] # if TAG contains -beta or starts with "b"
          then
            echo "This is a beta release"
            TARGET_BRANCH="beta"
          elif [[ $VERSION == v* || $VERSION == *"-release"*  ]] # if TAG starts with "v" or contains -release
          then
            echo "This is a 'release'."
            TARGET_BRANCH="release"
          fi
          
          echo -e "github.ref_name = ${{ github.ref_name }}"
          subversion_text=""
          if [[ ${{ github.ref_name }} =~ -beta(.*) ]]; then
            subversion_text="${BASH_REMATCH[1]}"
            echo "Found '-beta', extracted: '$subversion_text'"
          elif [[ ${{ github.ref_name }} =~ -test(.*) ]]; then
            subversion_text="${BASH_REMATCH[1]}"
            echo "Found '-test', extracted: '$subversion_text'"
          fi
          subversion_text="${subversion_text// }" # Remove all spaces
          
          echo "global-tag-type=\"$TARGET_BRANCH\"" >> "$GITHUB_OUTPUT"
          echo "global-subversion-text=$subversion_text" >> "$GITHUB_OUTPUT"
          echo "global-special-build_text=\"#define SPECIAL_BUILD\" " >> "$GITHUB_OUTPUT"
          
          echo -e "VERSION_HPP: $VERSION_HPP"
          echo -e "subversion_text: '$subversion_text'"

      - name: Check Variable
        shell: bash
        run: |
          echo -e "\nGlobal Variable value for 'global-tag-type' is: ${{ steps.strings.outputs.global-tag-type }} "
          echo -e "\nGlobal Variable value for 'global-special-build_text' is: ${{ steps.strings.outputs.global-special-build_text }} "
          echo -e "\nGlobal Variable value for 'global-subversion-text' is: ${{ steps.strings.outputs.global-subversion-text }} "
  
  build-lin:
    #if: ( 1 == 2 )
    runs-on: ubuntu-latest
    needs: [pre-build]
    strategy: # Set fail-fast too false to ensure that feedback is delivered for all matrix combinations. Consider changing this to true when your workflow is stable.
      fail-fast: true
      matrix:
        os: [ubuntu-latest]
        # build_type: [ Debug, Release ]
        build_type: [ Debug ]
        c_compiler: [gcc]
        #gcc_version: [11]
        include:
          - os: ubuntu-latest
            c_compiler: gcc
            cpp_compiler: g++

    steps:
      - uses: actions/checkout@v4

      - name: Set Linux reusable strings
        # Turn repeated input strings (such as the build output directory) into step outputs. These step outputs can be used throughout the workflow file.
        id: strings
        shell: bash
        run: |
          echo "build-output-dir=${{ github.workspace }}/cmake_build" >> "$GITHUB_OUTPUT"
          echo "target-folder=${{ github.workspace }}/release/lin_x64" >> "$GITHUB_OUTPUT"
          echo "plugin-name=missionx" >> "$GITHUB_OUTPUT"
          
          echo "OS Build: ${{ matrix.os }}"
          
          echo "global-tag-type: ${{ needs.pre-build.outputs.global-tag-type }} "
          echo "global-special-build_text: ${{ needs.pre-build.outputs.global-special-build_text }} "
          echo "global-subversion-text is: ${{ needs.pre-build.outputs.global-subversion-text }} "            

      - name: Prepare Linux libraries
        shell: bash
        run: |
          set -x
          sudo apt update
          gcc --version
          TAG=${GITHUB_REF##*/}
          if [ ! -z "$TAG" ]; then
            echo "VERSION=$TAG" > version.mak
          fi

      - name: Check Linux Stats
        shell: bash
        run: |
          echo -e "\n---->\nnproc:"
          nproc
          echo -e "\nlscpu:"
          lscpu

      # Configure CMake in a 'build' subdirectory. `CMAKE_BUILD_TYPE` is only required if you are using a single-configuration generator such as make.
      # See https://cmake.org/cmake/help/latest/variable/CMAKE_BUILD_TYPE.html?highlight=cmake_build_type
      - name: Debug - Configure & Build Linux using CMake
        run: >
          cmake -B ${{ steps.strings.outputs.build-output-dir }} -DCMAKE_CXX_COMPILER=${{ matrix.cpp_compiler }} -DCMAKE_C_COMPILER=${{ matrix.c_compiler }} -DCMAKE_BUILD_TYPE=${{ matrix.build_type }} -S ${{ github.workspace }}
          
      - name: Build
        # Build your program with the given configuration. Note that --config is needed because the default Windows generator is a multi-config generator (Visual Studio generator).
        run: cmake --build ${{ steps.strings.outputs.build-output-dir }} --config ${{ matrix.build_type }} -- -j 2
